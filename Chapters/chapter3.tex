%!TEX root =../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter1.tex
%% NOVA thesis document file
%%
%% Chapter with introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter3.tex}%

\chapter{Related work}
\label{cha:Related work}
  
\prependtographicspath{{Chapters/Figures/Covers/}}

\cite{wake2004refactoring}
\cite{estructuringArnold1989}
\cite{articleOpdyke}
\cite{RefactoringFowler2002}
\cite{SurveyRefactoring2004}
\cite{smellsRefactoring2020}
\cite{30yearsSoftwareRefactoring2020}
\cite{ManagingMaintenance1983}

\section{Restructuring and Refactoring}

"Refactoring is the art of improving the design of existing code. Refactoring provides us with ways to recognize problematic code and gives us recipes for improving it."

\subsection{Explanation and Goals}

Software is modified and inevitably evolves, generally increasing in complexity and drifting away from its original design. Such quality degradation makes maintenance necessary for the repair of faults, adaptation to new environments, and addition of functionalities. Methods have to be provided for reducing complexity while improving internal software quality. Restructuring or refactoring is a transformation of code at the same level of abstraction that aims to preserve external behavior in object-oriented development.
The term "refactoring" was coined by William Opdyke, who defined it as improving a software system's internal structure without changing its external behavior—better facilitating future adaptations and extensions.

\subsection{Effects}

It improves software quality attributes related to extensibility, modularity, and reusability, reduces complexity improves maintainability, and enhances efficiency. They transform the legacy or deteriorated code into a more modular form and support code migration to other languages or paradigms. The refactoring can aid in reducing development time, detecting bugs, reducing technical debt, and reducing the impact that code smells would have on maintainability.

\subsection{Methods, Approaches, and Instruments}

Refactoring includes the steps of identifying the points to be improved, defining proper methods, ensuring behavior preservation, applying refactoring, measuring the impact of refactoring on quality enhancement, and lastly, keeping in tandem or consistency with other software artifacts. Several tools take part in these activities in a systematic effort to improve code quality. The research on platforms like GitHub has spotlighted standard practices regarding refactorings—method extraction—and unveiled smell detection and refactoring tools.

\subsection{Challenges and Recommended Approaches}

It is hard for developers to understand refactoring operations based on the intentions of other developers. Modification that does not change any functionality is always hard to explain. However, refactoring is one of the essential future developments, particularly for long-lived software developed by many different developers. Some studies show an understanding of the motivations behind code changes or the introduction and removal of code smells; hence, it calls for best practices to maximize the benefit affirmed by refactoring. Challenges and Best Practices Software maintenance accounts for a large portion of the costs associated with software. These activities include fault repair, adaptation to various environments, and modification of functionalities. Some factors that hinder easy maintenance include unhelpful documentation, where complex source code is the only primary reliable information source. Common pitfalls, anti-patterns, and code smells are some negative factors impacting maintainability. Refactoring is such that it is principal to removing code smells and improving its quality; however, it is not easy to detect smells and apply the appropriate refactorings. Automated support for the same is hence critical.



\section{Reverse Engineering}

Reverse engineering in the context of software engineering refers to the process of examining a system to identify its components, their interaction, and their respective designs. The practice is vital in maintaining, updating, and enhancing legacy systems to address new requirements or work in new environments \cite{ReverseEngineering2011}.

\subsection{Reverse Engineering Techniques}

Static Analysis: This is a technique wherein the software's source code is statically analyzed without its execution. Parsing only the relevant code fragments can be done with the help of tools like DMS and island parsers. In cases when source code is not available, decompilation tools are used to reverse the binary code into some higher-order language. The fact extractors and semantic analyzers give an idea about the dependencies and data flows of the software \cite{ReverseEngineering1990}.

Dynamic Analysis: This technique complements static analysis through observation of the software during execution to capture its runtime behavior. Instrumentation of the program is done for data collection with the view of finding out operational profiles and runtime problems, which are difficult or not possible to observe in static analysis—the tools for execution trace analysis help in discovering invariants and extracting relevant patterns from execution \cite{ReverseEngineering1990} \cite{ReverseEngineering2011}.

Historical Analysis: Fetches data from versioning and bug tracking systems to analyze the evolution of software artifacts, seeking when and why the changes took place. The technique supports the integration of different sources of information and uses tools supporting efficient analysis for detecting changes between different versions of software and for change tracking as well \cite{ReverseEngineering1990}.

\subsection{Key Concepts and Definitions}

Forward Engineering: This is the traditional process whereby one goes from high-level abstractions and designs to the concrete physical implementation of a system \cite{ReverseEngineering2005}.
Reverse Engineering: This is the opposite of forward engineering since it deconstructs a system to support the creation of higher-level representations of the system, and it emphasizes the understanding of the structure and behavior predominantly without modification \cite{ReverseEngineering2005} \cite{ReverseEngineering2011}.

Subareas of Reverse Engineering \cite{ReverseEngineering2011}: 
\begin{itemize}
  \item \textbf{Redocumentation:} It generates semantically equivalent documentation of a system by pretty printers and crossreference listings.
  
  \item \textbf{Design Recovery:} A process for re-creating higher-level abstraction using external information and domain knowledge.
  
  \item \textbf{Restructuring:} A system representation transformation that, to the greatest extent possible, is behavior-preserving concerning its external behavior and yet helps a system undergo improvement without interfering with its functionality.
\end{itemize}

Reverse engineering is an essential means of software system analysis and improvement, especially for detailed and systematic disassembly and possible reuse of already existing software assets \cite{ReverseEngineering1990}.



\section{Reengineering}

Reengineering is a comprehensive approach to examining and transforming software systems to meet new requirements or improve functionality and maintainability. It involves more extensive changes than refactoring or restructuring, often addressing broader aspects of the system, including its architecture and design principles.

\subsection{Reengineering Patterns}

Reengineering patterns provide structured methodologies to address common challenges in reengineering projects, encapsulating expert knowledge and proven practices. These patterns are context-specific and documented using a template that includes the problem context, solution, forces and trade-offs, examples, known uses, and related patterns. This helps engineers manage complex reengineering tasks by breaking them down into more manageable parts.

\subsection{Refactoring and Reengineering Patterns}

Refactoring focuses on improving code structure without altering external behavior, while reengineering involves significant changes to align the system with new requirements. Refactoring patterns provide incremental improvement techniques, whereas reengineering patterns offer strategies for comprehensive system transformation. For example, the "Speculate About Design" pattern involves creating and validating high-level design models against existing code.

\subsection{Pattern Systems and Languages}

Reengineering patterns are organized into systems or languages. A pattern system is a collection of related patterns addressing different aspects of a problem, while a pattern language integrates patterns to achieve a comprehensive solution. For instance, a pattern system for legacy code might include introducing unit tests and managing dependencies, while a pattern language like Temporal Details helps manage the evolution of program representations over time.

\subsection{Difficulties in Reengineering Patterns}

Challenges in reengineering patterns include the lack of documented experience reports, scarcity of recognized experts, and the absence of explicitly listed forces and trade-offs. The lack of published reengineering experiences hinders pattern validation, and the field's lower prestige leads to fewer recognized experts. Despite these issues, works by authors like Fowler, Feathers, and Lanza are valuable for their structured approaches and practical solutions.

Leveraging reengineering patterns, systems, and languages helps software engineers manage the complexity of reengineering tasks, transforming legacy systems into robust, modern, and maintainable forms. Addressing the difficulties in reengineering patterns enhances their applicability and effectiveness in real-world scenarios.

\cite{SoftwareEvolutionMens2008}
\cite{RefactoringFowler2002}

\cite{DevelopmentModels2010} \cite{ContinuousEngineering2017}.


